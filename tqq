[1mdiff --git a/applications/visual_tests/test_bh_sne.cpp b/applications/visual_tests/test_bh_sne.cpp[m
[1mindex 8f80976..3dada73 100644[m
[1m--- a/applications/visual_tests/test_bh_sne.cpp[m
[1m+++ b/applications/visual_tests/test_bh_sne.cpp[m
[36m@@ -57,6 +57,10 @@[m
 #include "weighted_tsne.h"[m
 [m
 int main(int argc, char *argv[]){[m
[32m+[m
[32m+[m	[32mSetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS);[m
[32m+[m
[32m+[m
     try{[m
         typedef float scalar_type;[m
 		typedef std::vector<hdi::data::MapMemEff<uint32_t, float>> sparse_scalar_matrix;[m
[36m@@ -376,64 +380,70 @@[m [mint main(int argc, char *argv[]){[m
         drawer.setPointSize(5);[m
         viewer.addDrawer(&drawer);[m
 [m
[31m-        int iter = 0;[m
[31m-        while(true){[m
[31m-			wt->do_iteration();[m
[31m-[m
[31m-			// Selection growing[m
[31m-			float alpha = (iter - 250) / 300.0;[m
[31m-			alpha = alpha > 1.0 ? 1.0 : (alpha < 0.0 ? 0.0 : alpha);[m
[31m-[m
[31m-			// Set point location at every iteration < 800[m
[31m-			//wt->lerp(selectionEmbeddingStart, selectionEmbeddingFinal, selectionEmbeddingCurrent, alpha);[m
[31m-			//wt->set_coordinates(selectedIndices, selectionEmbeddingCurrent);[m
[31m-[m
[31m-			// Lerp the weights[m
[31m-			//wt->lerp(one_weights, selected_high, lerp_weights, alpha);[m
[31m-			//wt->tSNE.setWeights(lerp_weights, lerp_weights, one_weights, one_weights);[m
[31m-			if(iter == 1000) {[m
[31m-				//int k = 200;[m
[31m-				//std::vector<int> highDimNeighbours;[m
[31m-				//std::vector<int> lowDimNeighbours;[m
[31m-[m
[31m-				//// highDimNeighbours, lowDimNeighbours, includes the point itself as its nearest neighbour[m
[31m-				//wt->compute_neighbours(wt->data, N, input_dims, k, highDimNeighbours);[m
[31m-				//wt->compute_neighbours(wt->embedding.getContainer(), N, output_dims, k, lowDimNeighbours);[m
[31m-[m
[31m-				std::vector<float> errors(N, 0);[m
[31m-				//wt->calculate_percentage_error(lowDimNeighbours, highDimNeighbours, per_errors, N, k + 1, k);[m
[31m-				wt->calculate_kl_divergence(errors);[m
[31m-[m
[31m-				wt->write_csv(errors, N, 1, "C:/Users/basti/Google Drive/Learning/Master Thesis/ThesisDatasets/Generated/errors.csv");[m
[31m-			}[m
[31m-[m
[31m-            {//limits[m
[31m-                std::vector<scalar_type> limits;[m
[31m-                wt->embedding.computeEmbeddingBBox(limits,0.25);[m
[31m-                auto tr = QVector2D(limits[1],limits[3]);[m
[31m-                auto bl = QVector2D(limits[0],limits[2]);[m
[31m-		/*		float lim = 15;[m
[31m-				auto tr = QVector2D(lim, lim);[m
[31m-				auto bl = QVector2D(-lim, -lim);*/[m
[31m-                viewer.setTopRightCoordinates(tr);[m
[31m-                viewer.setBottomLeftCoordinates(bl);[m
[31m-[m
[31m-			/*	if ((iter % 100) == 0) {[m
[32m+[m		[32mint iter = 0;[m
[32m+[m
[32m+[m		[32m{[m
[32m+[m			[32mhdi::utils::ScopedTimer<float, hdi::utils::Milliseconds> timer(iteration_time);[m
[32m+[m
[32m+[m			[32mwhile (iter<1000) {[m
[32m+[m				[32mwt->do_iteration();[m
[32m+[m
[32m+[m				[32m// Selection growing[m
[32m+[m				[32mfloat alpha = (iter - 250) / 300.0;[m
[32m+[m				[32malpha = alpha > 1.0 ? 1.0 : (alpha < 0.0 ? 0.0 : alpha);[m
[32m+[m
[32m+[m				[32m// Set point location at every iteration < 800[m
[32m+[m				[32m//wt->lerp(selectionEmbeddingStart, selectionEmbeddingFinal, selectionEmbeddingCurrent, alpha);[m
[32m+[m				[32m//wt->set_coordinates(selectedIndices, selectionEmbeddingCurrent);[m
[32m+[m
[32m+[m				[32m// Lerp the weights[m
[32m+[m				[32m//wt->lerp(one_weights, selected_high, lerp_weights, alpha);[m
[32m+[m				[32m//wt->tSNE.setWeights(lerp_weights, lerp_weights, one_weights, one_weights);[m
[32m+[m				[32mif (iter == 1000) {[m
[32m+[m					[32m//int k = 200;[m
[32m+[m					[32m//std::vector<int> highDimNeighbours;[m
[32m+[m					[32m//std::vector<int> lowDimNeighbours;[m
[32m+[m
[32m+[m					[32m//// highDimNeighbours, lowDimNeighbours, includes the point itself as its nearest neighbour[m
[32m+[m					[32m//wt->compute_neighbours(wt->data, N, input_dims, k, highDimNeighbours);[m
[32m+[m					[32m//wt->compute_neighbours(wt->embedding.getContainer(), N, output_dims, k, lowDimNeighbours);[m
[32m+[m
[32m+[m					[32mstd::vector<float> errors(N, 0);[m
[32m+[m					[32m//wt->calculate_percentage_error(lowDimNeighbours, highDimNeighbours, per_errors, N, k + 1, k);[m
[32m+[m					[32mwt->calculate_kl_divergence(errors);[m
[32m+[m
[32m+[m					[32mwt->write_csv(errors, N, 1, "C:/Users/basti/Google Drive/Learning/Master Thesis/ThesisDatasets/Generated/errors.csv");[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m				[32m{//limits[m
[32m+[m					[32mstd::vector<scalar_type> limits;[m
[32m+[m					[32mwt->embedding.computeEmbeddingBBox(limits, 0.25);[m
[32m+[m					[32mauto tr = QVector2D(limits[1], limits[3]);[m
[32m+[m					[32mauto bl = QVector2D(limits[0], limits[2]);[m
[32m+[m					[32m/*		float lim = 15;[m
[32m+[m					[32mauto tr = QVector2D(lim, lim);[m
[32m+[m					[32mauto bl = QVector2D(-lim, -lim);*/[m
[32m+[m					[32mviewer.setTopRightCoordinates(tr);[m
[32m+[m					[32mviewer.setBottomLeftCoordinates(bl);[m
[32m+[m
[32m+[m					[32m/*	if ((iter % 100) == 0) {[m
 					hdi::utils::secureLogValue(&log, "tr1", limits[1]);[m
 					hdi::utils::secureLogValue(&log, "tr2", limits[3]);[m
[31m-				}*/[m
[31m-            }[m
[32m+[m					[32m}*/[m
[32m+[m				[32m}[m
 [m
 [m
[31m-            if((iter%1) == 0){[m
[31m-                viewer.updateGL();[m
[31m-				hdi::utils::secureLogValue(&log, "Iter", iter);[m
[31m-            }[m
[32m+[m				[32mif ((iter % 1) == 0) {[m
[32m+[m					[32mviewer.updateGL();[m
[32m+[m					[32mhdi::utils::secureLogValue(&log, "Iter", iter);[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m				[32mQApplication::processEvents();[m
[32m+[m				[32m++iter;[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
 [m
[31m-			[m
[31m-            QApplication::processEvents();[m
[31m-            ++iter;[m
[31m-        }[m
[32m+[m		[32mhdi::utils::secureLogValue(&log, "Average iteration time (ms): ", iteration_time / (float)iter);[m
 [m
         return app.exec();[m
     }[m
[1mdiff --git a/hdi/dimensionality_reduction/sparse_tsne_user_def_probabilities_inl.h b/hdi/dimensionality_reduction/sparse_tsne_user_def_probabilities_inl.h[m
[1mindex 07440a6..06c6424 100644[m
[1m--- a/hdi/dimensionality_reduction/sparse_tsne_user_def_probabilities_inl.h[m
[1m+++ b/hdi/dimensionality_reduction/sparse_tsne_user_def_probabilities_inl.h[m
[36m@@ -414,7 +414,7 @@[m [mnamespace hdi{[m
 [m
             std::vector<hp_scalar_type> sum_Q_subvalues(getNumberOfDataPoints(), 0);[m
 [m
[31m-            //#pragma omp parallel for[m
[32m+[m[32m            #pragma omp parallel for[m[41m[m
             for(int n = 0; n < getNumberOfDataPoints(); n++){[m
 				// Compute F_rep * Z for each data point[m
                 sptree.computeNonEdgeForcesOMP(n, _theta, negative_forces.data() + n * _params._embedding_dimensionality, sum_Q_subvalues[n]);[m
